/* clang-format off */
/*
 * SPDX-FileCopyrightText: Copyright (c) 2026, NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
/* clang-format on */

#pragma once

#include <algorithm>
#include <cstdint>
#include <tuple>
#include <vector>

namespace cuopt::linear_programming::dual_simplex {

// Event types generated by B&B workers during deterministic execution
enum class bb_event_type_t : int8_t {
  NODE_BRANCHED   = 0,
  NODE_FATHOMED   = 1,
  NODE_INTEGER    = 2,
  NODE_INFEASIBLE = 3,
  NODE_NUMERICAL  = 4,
};

template <typename i_t, typename f_t>
struct branched_payload_t {
  i_t down_child_id;
  i_t up_child_id;
  f_t node_lower_bound;
  i_t branch_var;
  f_t branch_value;
};

template <typename f_t>
struct integer_solution_payload_t {
  f_t objective_value;
};

template <typename f_t>
struct fathomed_payload_t {
  f_t lower_bound;
};

template <typename i_t, typename f_t>
struct bb_event_t {
  bb_event_type_t type;
  double work_timestamp;
  int worker_id;
  i_t node_id;
  int event_sequence;

  union {
    branched_payload_t<i_t, f_t> branched;
    integer_solution_payload_t<f_t> integer_solution;
    fathomed_payload_t<f_t> fathomed;
  } payload;

  bb_event_t()
    : type(bb_event_type_t::NODE_FATHOMED),
      work_timestamp(0.0),
      worker_id(0),
      node_id(0),
      event_sequence(0)
  {
    payload.fathomed = {0.0};
  }

  bool operator<(const bb_event_t& other) const
  {
    return std::tie(work_timestamp, worker_id, node_id, event_sequence) <
           std::tie(other.work_timestamp, other.worker_id, other.node_id, other.event_sequence);
  }

  static bb_event_t make_branched(double work_unit_ts,
                                  int worker,
                                  i_t node,
                                  i_t down_id,
                                  i_t up_id,
                                  f_t lower_bound,
                                  i_t branch_var,
                                  f_t branch_val)
  {
    bb_event_t e;
    e.type             = bb_event_type_t::NODE_BRANCHED;
    e.work_timestamp   = work_unit_ts;
    e.worker_id        = worker;
    e.node_id          = node;
    e.payload.branched = {down_id, up_id, lower_bound, branch_var, branch_val};
    return e;
  }

  static bb_event_t make_integer_solution(double work_unit_ts, int worker, i_t node, f_t objective)
  {
    bb_event_t e;
    e.type                     = bb_event_type_t::NODE_INTEGER;
    e.work_timestamp           = work_unit_ts;
    e.worker_id                = worker;
    e.node_id                  = node;
    e.payload.integer_solution = {objective};
    return e;
  }

  static bb_event_t make_fathomed(double work_unit_ts, int worker, i_t node, f_t lower_bound)
  {
    bb_event_t e;
    e.type             = bb_event_type_t::NODE_FATHOMED;
    e.work_timestamp   = work_unit_ts;
    e.worker_id        = worker;
    e.node_id          = node;
    e.payload.fathomed = {lower_bound};
    return e;
  }

  static bb_event_t make_infeasible(double work_unit_ts, int worker, i_t node)
  {
    bb_event_t e;
    e.type           = bb_event_type_t::NODE_INFEASIBLE;
    e.work_timestamp = work_unit_ts;
    e.worker_id      = worker;
    e.node_id        = node;
    return e;
  }

  static bb_event_t make_numerical(double work_unit_ts, int worker, i_t node)
  {
    bb_event_t e;
    e.type           = bb_event_type_t::NODE_NUMERICAL;
    e.work_timestamp = work_unit_ts;
    e.worker_id      = worker;
    e.node_id        = node;
    return e;
  }
};

template <typename i_t, typename f_t>
struct bb_event_batch_t {
  std::vector<bb_event_t<i_t, f_t>> events;

  void clear() { events.clear(); }

  void add(bb_event_t<i_t, f_t> event) { events.push_back(std::move(event)); }

  void sort_for_replay() { std::sort(events.begin(), events.end()); }

  size_t size() const { return events.size(); }
  bool empty() const { return events.empty(); }
};

}  // namespace cuopt::linear_programming::dual_simplex
