/*
 * SPDX-FileCopyrightText: Copyright (c) 2025-2026, NVIDIA CORPORATION. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

#include "header.h"

static const double threshold[] = {
  940.50000000000011,
  962.50000000000011,
  964.50000000000011,
  1001.5000000000001,
  1010.5000000000001,
  1088.5000000000002,
  1250.5000000000002,
  1435.5000000000002,
  3395.5000000000005,
  3603.0000000000005,
  4535.5000000000009,
  5197.5000000000009,
  5419.0000000000009,
  5949.5000000000009,
  5959.5000000000009,
  5962.5000000000009,
  5963.5000000000009,
  5964.5000000000009,
  5966.5000000000009,
  5969.5000000000009,
  5972.5000000000009,
  5984.0000000000009,
  6803.5000000000009,
  7344.0000000000009,
  8291.0000000000018,
  9184.0000000000018,
  9992.0000000000018,
  10730.500000000002,
  12831.000000000002,
  14626.500000000002,
  15810.500000000002,
  16371.000000000002,
  17411.000000000004,
  18723.500000000004,
  19548.000000000004,
  20752.500000000004,
  23386.000000000004,
  35418.500000000007,
  49402.000000000007,
  53915.500000000007,
  598.50000000000011,
  1717.5000000000002,
  1767.5000000000002,
  1847.5000000000002,
  2005.5000000000002,
  2290.0000000000005,
  2305.5000000000005,
  2649.0000000000005,
  5179.5000000000009,
  5250.5000000000009,
  5362.5000000000009,
  6412.5000000000009,
  7682.0000000000009,
  9243.0000000000018,
  10037.000000000002,
  12675.000000000002,
  18404.000000000004,
  19600.500000000004,
  21814.500000000004,
  23409.000000000004,
  23497.000000000004,
  23508.000000000004,
  23558.000000000004,
  23603.500000000004,
  23652.500000000004,
  23744.500000000004,
  23818.500000000004,
  23827.000000000004,
  23874.000000000004,
  23897.500000000004,
  23920.500000000004,
  23949.500000000004,
  23978.000000000004,
  24015.000000000004,
  24102.000000000004,
  24164.500000000004,
  26354.000000000004,
  40391.500000000007,
  58010.500000000007,
  64224.000000000007,
  64894.000000000007,
  5656.5000000000009,
  7438.5000000000009,
  7622.5000000000009,
  18609.000000000004,
  23424.500000000004,
  24989.500000000004,
  29342.000000000004,
  43154.000000000007,
  46402.000000000007,
  46815.000000000007,
  47052.000000000007,
  47178.000000000007,
  47358.000000000007,
  47388.000000000007,
  47485.000000000007,
  47659.000000000007,
  47752.500000000007,
  47839.500000000007,
  48007.000000000007,
  48085.500000000007,
  48300.500000000007,
  48410.000000000007,
  54272.500000000007,
  57404.000000000007,
  76382.000000000015,
  83368.000000000015,
  108268.00000000001,
  170279.00000000003,
  186892.00000000003,
  3.8570000000000007,
  9.8880000000000017,
  11.190500000000002,
  11.561500000000001,
  11.861500000000001,
  12.013500000000002,
  12.3085,
  12.4625,
  12.647500000000003,
  13.102500000000001,
  13.439500000000001,
  14.092500000000003,
  15.505500000000003,
  16.265500000000003,
  16.586500000000004,
  16.893500000000003,
  17.051500000000001,
  17.255500000000001,
  17.432500000000001,
  17.537500000000005,
  17.814500000000006,
  18.095500000000005,
  18.167500000000004,
  18.334500000000002,
  18.546500000000005,
  18.743500000000001,
  18.851500000000005,
  18.949500000000004,
  19.151500000000002,
  19.201500000000006,
  19.275500000000005,
  19.453500000000002,
  19.604500000000005,
  19.704500000000003,
  20.009500000000006,
  20.944500000000001,
  21.655500000000004,
  24.058500000000006,
  56.284500000000001,
  58.642500000000005,
  63.514000000000003,
  66.785000000000011,
  67.949500000000015,
  70.709000000000017,
  72.252000000000024,
  74.410500000000013,
  76.675500000000014,
  78.813500000000019,
  81.035000000000011,
  86.201000000000008,
  87.71850000000002,
  90.722000000000023,
  93.919500000000014,
  95.885000000000005,
  98.094500000000025,
  101.17400000000002,
  105.48300000000002,
  119.34800000000001,
  135.33800000000005,
  148.20100000000002,
  155.32500000000002,
  202.12250000000003,
  215.85450000000003,
  222.94300000000001,
  227.80600000000001,
  231.09150000000002,
  235.98200000000006,
  238.51450000000003,
  289.45400000000001,
  328.42950000000002,
  358.75900000000007,
  402.21050000000008,
  420.89000000000004,
  436.57650000000007,
  443.69200000000006,
  453.70450000000005,
  462.34700000000004,
  471.61900000000009,
  478.55100000000004,
  486.96150000000006,
  495.03150000000005,
  501.28050000000007,
  505.49750000000006,
  510.61650000000003,
  518.64250000000004,
  524.98750000000007,
  530.02200000000005,
  538.52950000000021,
  548.17750000000012,
  563.13350000000003,
  585.95900000000017,
  606.86650000000009,
  622.19850000000008,
  632.28650000000016,
  662.49250000000006,
  870.10250000000008,
  885.30550000000005,
  899.1785000000001,
  914.79400000000021,
  932.5870000000001,
  945.74600000000009,
  1009.9455000000002,
  1021.0850000000002,
  1048.7770000000003,
  1084.9000000000003,
  1115.9705000000001,
  1145.3940000000002,
  1175.9330000000002,
  1208.2720000000002,
  1235.9550000000002,
  1253.6805000000002,
  1266.5855000000004,
  1276.1255000000003,
  1282.5315000000003,
  1291.7940000000001,
  1295.7590000000002,
  1299.4545000000001,
  1307.3780000000004,
  1312.9645000000003,
  1322.5440000000001,
  1465.1910000000003,
};

static const int th_begin[] = {
  0,
  40,
  81,
  110,
};

static const int th_len[] = {
  40,
  41,
  29,
  121,
};

/*
 * \brief Function to convert a feature value into bin index.
 * \param val Feature value, in floating-point
 * \param fid Feature identifier
 * \return bin Index corresponding to given feature value
 */
int cpufj_predictor::quantize(double val, unsigned fid)
{
  const size_t offset = th_begin[fid];
  const double* array = &threshold[offset];
  int len             = th_len[fid];
  int low             = 0;
  int high            = len;
  int mid;
  double mval;
  // It is possible th_begin[i] == [total_num_threshold]. This means that
  // all features i, (i+1), ... are not used for any of the splits in the model.
  // So in this case, just return something
  if (offset == 231 || val < array[0]) { return -10; }
  while (low + 1 < high) {
    mid  = (low + high) / 2;
    mval = array[mid];
    if (val == mval) {
      return mid * 2;
    } else if (val < mval) {
      high = mid;
    } else {
      low = mid;
    }
  }
  if (array[low] == val) {
    return low * 2;
  } else if (high == len) {
    return len * 2;
  } else {
    return low * 2 + 1;
  }
}
